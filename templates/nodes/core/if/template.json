{
    "name": "If (Conditional Router)",
    "description": "Routes workflow items to different branches based on conditions. Supports complex filtering logic with true/false outputs. Features version-gated type validation and sophisticated error handling for robust conditional processing.",
    "category": "workflow_control",
    "service": "core",
    "node": {
        "parameters": {
            "conditions": {
                "type": "filter",
                "default": {},
                "description": "Filter conditions for routing items",
                "typeOptions": {
                    "filter": {
                        "caseSensitive": "={{!$parameter.options.ignoreCase}}",
                        "typeValidation": "version-dependent strictness",
                        "version": "={{ $nodeVersion >= 2.2 ? 2 : 1 }}"
                    }
                },
                "required": true
            },
            "looseTypeValidation": {
                "type": "boolean",
                "default": false,
                "description": "Enable loose type validation for compatibility",
                "displayOptions": {
                    "show": {
                        "@version": [
                            {
                                "_cnd": {
                                    "gte": 2.1
                                }
                            }
                        ]
                    }
                }
            },
            "options": {
                "type": "collection",
                "default": {},
                "description": "Additional configuration options",
                "options": {
                    "ignoreCase": {
                        "type": "boolean",
                        "default": true,
                        "description": "Whether to ignore letter case when evaluating conditions"
                    },
                    "looseTypeValidation": {
                        "type": "boolean",
                        "default": false,
                        "description": "Enable loose type validation within options"
                    }
                }
            }
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": [
            2,
            2.1,
            2.2
        ],
        "credentials": [],
        "outputs": [
            {
                "type": "main",
                "displayName": "true"
            },
            {
                "type": "main",
                "displayName": "false"
            }
        ],
        "inputs": [
            {
                "type": "main"
            }
        ],
        "properties": {
            "color": "#408000",
            "icon": "fa:map-signs",
            "iconColor": "green",
            "parameterPane": "wide"
        },
        "notes": "Implements VersionedNodeType pattern with sophisticated error handling and context preservation"
    },
    "production_patterns": {
        "architecture": {
            "versioned_node": "Extends VersionedNodeType for multi-version support",
            "version_mapping": "Maps versions 1, 2, 2.1, 2.2 to specific implementations",
            "backward_compatibility": "Maintains compatibility across version upgrades"
        },
        "dual_output": {
            "routing_strategy": "Routes items to true/false outputs based on condition evaluation",
            "output_naming": "Clear semantic naming: 'true' and 'false' outputs",
            "item_preservation": "Maintains pairedItem relationships for data lineage"
        },
        "error_handling": {
            "context_preservation": "Enriches errors with itemIndex and node context",
            "graceful_degradation": "Routes failed items to false output when continueOnFail enabled",
            "type_validation_errors": "Provides specific guidance for type validation failures",
            "error_classification": "Distinguishes between NodeOperationError and ApplicationError"
        },
        "type_validation": {
            "version_gated": "Type validation strictness varies by node version",
            "user_configurable": "Allows users to enable loose validation",
            "error_enhancement": "Adds helpful error descriptions for validation failures"
        },
        "performance": {
            "batch_processing": "Processes all input items in single execution",
            "memory_efficient": "Uses array push for output collection",
            "early_termination": "Supports continueOnFail for resilient processing"
        }
    },
    "implementation_template": {
        "versioned_constructor": {
            "pattern": "VersionedNodeType with baseDescription and nodeVersions mapping",
            "example": "constructor() { super(nodeVersions, baseDescription); }"
        },
        "execution_method": {
            "pattern": "Dual array collection with conditional routing",
            "example": "const [trueItems, falseItems] = [[], []]; if (pass) trueItems.push(item); else falseItems.push(item);"
        },
        "error_context": {
            "pattern": "Error enrichment with lodash set",
            "example": "set(error, 'context.itemIndex', itemIndex); set(error, 'node', this.getNode());"
        },
        "type_validation": {
            "pattern": "Version-dependent validation with fallback",
            "example": "getTypeValidationParameter(2.1)(this, itemIndex, options.looseTypeValidation)"
        },
        "condition_evaluation": {
            "pattern": "Safe parameter extraction with error handling",
            "example": "this.getNodeParameter('conditions', itemIndex, false, { extractValue: true })"
        },
        "paired_item_handling": {
            "pattern": "Automatic pairedItem assignment for lineage",
            "example": "if (item.pairedItem === undefined) item.pairedItem = { item: itemIndex };"
        }
    },
    "usage_guidelines": {
        "best_practices": [
            "Use semantic condition names that clearly indicate the filtering logic",
            "Enable case sensitivity when exact string matching is required",
            "Consider loose type validation for flexible data processing pipelines",
            "Test both true and false branches with representative data",
            "Use continueOnFail when partial failures should not stop the workflow"
        ],
        "configuration": {
            "condition_setup": "Configure filter conditions using the visual filter builder",
            "case_sensitivity": "Set ignoreCase option based on string matching requirements",
            "type_validation": "Enable loose validation for dynamic or varied data structures",
            "error_handling": "Configure continueOnFail based on error tolerance requirements"
        },
        "version_considerations": {
            "v1": "Legacy version with basic conditional logic",
            "v2": "Enhanced with filter conditions and improved error handling",
            "v2.1": "Added configurable type validation with backward compatibility",
            "v2.2": "Latest version with optimized filter processing and validation"
        },
        "performance_tips": [
            "Minimize complex condition logic for high-volume processing",
            "Use specific data type validations to prevent runtime errors",
            "Consider splitting complex conditions across multiple If nodes",
            "Enable continueOnFail for fault-tolerant processing workflows"
        ],
        "security": [
            "Validate input data types to prevent injection attacks",
            "Sanitize user-provided condition parameters",
            "Use type validation to enforce data integrity constraints",
            "Monitor error patterns for potential security issues"
        ]
    }
}
