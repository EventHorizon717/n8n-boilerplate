{
  "core_nodes": {
    "webhook_trigger": {
      "name": "Webhook Trigger Template",
      "description": "Standard webhook trigger configuration with authentication and validation",
      "category": "core",
      "node": {
        "parameters": {
          "httpMethod": "POST",
          "path": "workflow-webhook-path",
          "responseMode": "onReceived",
          "response": {
            "statusCode": 200,
            "body": "{{ {\"status\": \"received\", \"timestamp\": new Date().toISOString()} }}"
          },
          "options": {
            "noResponseBody": false,
            "rawBody": false,
            "allowedOrigins": "*"
          }
        },
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 1,
        "notes": "Replace 'workflow-webhook-path' with specific path for this webhook"
      },
      "validation": {
        "required_headers": ["Content-Type"],
        "expected_content_type": "application/json",
        "authentication": "optional"
      }
    },
    "conditional_switch": {
      "name": "Conditional Routing Switch",
      "description": "Switch node template for conditional routing based on data values",
      "category": "core",
      "node": {
        "parameters": {
          "mode": "expression",
          "output": "specified",
          "rules": {
            "rules": [
              {
                "id": "condition_1",
                "outputIndex": 0,
                "value": "={{ $json.status === 'active' }}"
              },
              {
                "id": "condition_2", 
                "outputIndex": 1,
                "value": "={{ $json.status === 'inactive' }}"
              },
              {
                "id": "condition_3",
                "outputIndex": 2,
                "value": "={{ $json.priority === 'high' }}"
              }
            ]
          },
          "fallbackOutput": 3
        },
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3,
        "notes": "Customize conditions based on your data structure and routing needs"
      }
    },
    "error_handler": {
      "name": "Error Handler Code Node",
      "description": "Comprehensive error handling and logging",
      "category": "core",
      "node": {
        "parameters": {
          "mode": "runOnceForAllItems",
          "jsCode": "// Error handling template\nconst items = $input.all();\nconst errorInfo = items[0]?.json || {};\n\n// Extract error details\nconst error = {\n  workflow_id: $workflow.id,\n  workflow_name: $workflow.name,\n  execution_id: $execution.id,\n  timestamp: new Date().toISOString(),\n  error_type: errorInfo.name || 'Unknown Error',\n  error_message: errorInfo.message || 'No error message provided',\n  error_code: errorInfo.code || null,\n  http_code: errorInfo.httpCode || null,\n  stack_trace: errorInfo.stack || null,\n  node_name: errorInfo.node?.name || 'Unknown Node',\n  input_data: errorInfo.cause?.data || null\n};\n\n// Log error details\nconsole.error('Workflow Error:', JSON.stringify(error, null, 2));\n\n// Determine error severity\nlet severity = 'medium';\nif (error.http_code >= 500 || error.error_type.includes('Database')) {\n  severity = 'high';\n} else if (error.http_code >= 400 && error.http_code < 500) {\n  severity = 'low';\n}\n\n// Create alert message\nconst alertMessage = {\n  subject: `Workflow Error: ${error.workflow_name}`,\n  body: `Error Details:\\nType: ${error.error_type}\\nMessage: ${error.error_message}\\nNode: ${error.node_name}\\nTime: ${error.timestamp}\\nExecution: ${error.execution_id}`,\n  severity: severity,\n  requires_attention: severity === 'high'\n};\n\nreturn [{json: {\n  error_details: error,\n  alert_message: alertMessage,\n  recovery_action: 'logged_and_alerted'\n}}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "notes": "Connect this to error outputs of other nodes"
      }
    },
    "data_validation": {
      "name": "Data Validation Code Node",
      "description": "JavaScript code node for comprehensive data validation",
      "category": "core",
      "node": {
        "parameters": {
          "mode": "runOnceForAllItems",
          "jsCode": "// Data validation template\nconst items = $input.all();\nconst validatedItems = [];\nconst errors = [];\n\n// Define validation rules\nconst validationRules = {\n  email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  phone: /^[\\+]?[1-9][\\d]{1,14}$/,\n  required: ['id', 'email'], // Add required fields\n  optional: ['name', 'phone'] // Add optional fields\n};\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i].json;\n  const validation = { row: i + 1, errors: [], warnings: [] };\n  \n  // Check required fields\n  validationRules.required.forEach(field => {\n    if (!item[field] || item[field].toString().trim() === '') {\n      validation.errors.push(`${field} is required`);\n    }\n  });\n  \n  // Validate email format\n  if (item.email && !validationRules.email.test(item.email)) {\n    validation.errors.push('Invalid email format');\n  }\n  \n  // Validate phone format\n  if (item.phone && !validationRules.phone.test(item.phone)) {\n    validation.warnings.push('Phone format may be invalid');\n  }\n  \n  // Add validation results\n  const processedItem = {\n    ...item,\n    validation_status: validation.errors.length === 0 ? 'valid' : 'invalid',\n    validation_errors: validation.errors,\n    validation_warnings: validation.warnings,\n    processed_at: new Date().toISOString()\n  };\n  \n  if (validation.errors.length === 0) {\n    validatedItems.push({json: processedItem});\n  } else {\n    errors.push({json: processedItem});\n  }\n}\n\nconsole.log(`Validation complete: ${validatedItems.length} valid, ${errors.length} invalid`);\n\n// Store errors for later use if needed\n$workflow.staticData.validationErrors = errors;\n\nreturn validatedItems;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "notes": "Customize validation rules in the validationRules object"
      }
    },
    "schedule_trigger": {
      "name": "Schedule Trigger Template",
      "description": "Cron-based schedule trigger with timezone support",
      "category": "core",
      "node": {
        "parameters": {
          "rule": {
            "interval": [
              {
                "field": "cronExpression",
                "expression": "0 9 * * 1-5"
              }
            ]
          },
          "timezone": "America/New_York"
        },
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1,
        "notes": "Default: weekdays at 9 AM EST. Adjust cron expression and timezone as needed"
      }
    },
    "manual_trigger": {
      "name": "Manual Trigger Template",
      "description": "Simple manual trigger for testing and on-demand execution",
      "category": "core",
      "node": {
        "parameters": {},
        "type": "n8n-nodes-base.manualTrigger",
        "typeVersion": 1,
        "notes": "Use for testing workflows or manual execution"
      }
    }
  },
  "usage_guidelines": {
    "triggers": {
      "webhook": "Use for external system integrations and real-time data processing",
      "schedule": "Use for periodic tasks, data synchronization, and batch processing",
      "manual": "Use for testing, debugging, and one-off executions"
    },
    "error_handling": {
      "always_include": "Include error handling for all critical workflow paths",
      "logging": "Use error_handler template for consistent error logging",
      "recovery": "Connect error outputs to appropriate recovery mechanisms"
    },
    "validation": {
      "input_validation": "Always validate external input using data_validation template",
      "type_checking": "Validate data types match expected schema",
      "business_rules": "Implement business-specific validation rules"
    },
    "routing": {
      "conditional_logic": "Use conditional_switch for complex routing scenarios",
      "multiple_outputs": "Configure appropriate number of outputs for all conditions",
      "fallback_handling": "Always configure fallback output for unmatched conditions"
    }
  }
}