{
  "node_templates": {
    "webhook_trigger": {
      "name": "Webhook Trigger Template",
      "description": "Standard webhook trigger configuration with authentication and validation",
      "node": {
        "parameters": {
          "httpMethod": "POST",
          "path": "workflow-webhook-path",
          "responseMode": "onReceived",
          "response": {
            "statusCode": 200,
            "body": "{{ {\"status\": \"received\", \"timestamp\": new Date().toISOString()} }}"
          },
          "options": {
            "noResponseBody": false,
            "rawBody": false,
            "allowedOrigins": "*"
          }
        },
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 1,
        "notes": "Replace 'workflow-webhook-path' with specific path for this webhook"
      },
      "validation": {
        "required_headers": ["Content-Type"],
        "expected_content_type": "application/json",
        "authentication": "optional"
      }
    },
    "http_request_with_retry": {
      "name": "HTTP Request with Retry Logic",
      "description": "HTTP request node with comprehensive error handling and retry configuration",
      "node": {
        "parameters": {
          "url": "https://api.example.com/endpoint",
          "method": "POST",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Accept",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "bodyContentType": "json",
          "jsonParameters": true,
          "options": {
            "timeout": 30000,
            "retry": {
              "enabled": true,
              "maxTries": 3,
              "waitBetweenTries": 2000
            },
            "response": {
              "fullResponse": false,
              "neverError": false
            }
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "notes": "Configure URL, authentication, and request body as needed"
      }
    },
    "data_validation": {
      "name": "Data Validation Code Node",
      "description": "JavaScript code node for comprehensive data validation",
      "node": {
        "parameters": {
          "mode": "runOnceForAllItems",
          "jsCode": "// Data validation template\nconst items = $input.all();\nconst validatedItems = [];\nconst errors = [];\n\n// Define validation rules\nconst validationRules = {\n  email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  phone: /^[\\+]?[1-9][\\d]{1,14}$/,\n  required: ['id', 'email'], // Add required fields\n  optional: ['name', 'phone'] // Add optional fields\n};\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i].json;\n  const validation = { row: i + 1, errors: [], warnings: [] };\n  \n  // Check required fields\n  validationRules.required.forEach(field => {\n    if (!item[field] || item[field].toString().trim() === '') {\n      validation.errors.push(`${field} is required`);\n    }\n  });\n  \n  // Validate email format\n  if (item.email && !validationRules.email.test(item.email)) {\n    validation.errors.push('Invalid email format');\n  }\n  \n  // Validate phone format\n  if (item.phone && !validationRules.phone.test(item.phone)) {\n    validation.warnings.push('Phone format may be invalid');\n  }\n  \n  // Add validation results\n  const processedItem = {\n    ...item,\n    validation_status: validation.errors.length === 0 ? 'valid' : 'invalid',\n    validation_errors: validation.errors,\n    validation_warnings: validation.warnings,\n    processed_at: new Date().toISOString()\n  };\n  \n  if (validation.errors.length === 0) {\n    validatedItems.push({json: processedItem});\n  } else {\n    errors.push({json: processedItem});\n  }\n}\n\nconsole.log(`Validation complete: ${validatedItems.length} valid, ${errors.length} invalid`);\n\n// Store errors for later use if needed\n$workflow.staticData.validationErrors = errors;\n\nreturn validatedItems;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "notes": "Customize validation rules in the validationRules object"
      }
    },
    "database_upsert": {
      "name": "Database Upsert Operation",
      "description": "PostgreSQL node configured for INSERT with ON CONFLICT (upsert) operation",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "INSERT INTO table_name (id, field1, field2, updated_at) VALUES ($1, $2, $3, CURRENT_TIMESTAMP) ON CONFLICT (id) DO UPDATE SET field1 = EXCLUDED.field1, field2 = EXCLUDED.field2, updated_at = CURRENT_TIMESTAMP",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.id }}",
              "={{ $json.field1 }}",
              "={{ $json.field2 }}"
            ]
          }
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Replace table_name and fields with actual database schema"
      }
    },
    "error_handler": {
      "name": "Error Handler Code Node",
      "description": "Comprehensive error handling and logging",
      "node": {
        "parameters": {
          "mode": "runOnceForAllItems",
          "jsCode": "// Error handling template\nconst items = $input.all();\nconst errorInfo = items[0]?.json || {};\n\n// Extract error details\nconst error = {\n  workflow_id: $workflow.id,\n  workflow_name: $workflow.name,\n  execution_id: $execution.id,\n  timestamp: new Date().toISOString(),\n  error_type: errorInfo.name || 'Unknown Error',\n  error_message: errorInfo.message || 'No error message provided',\n  error_code: errorInfo.code || null,\n  http_code: errorInfo.httpCode || null,\n  stack_trace: errorInfo.stack || null,\n  node_name: errorInfo.node?.name || 'Unknown Node',\n  input_data: errorInfo.cause?.data || null\n};\n\n// Log error details\nconsole.error('Workflow Error:', JSON.stringify(error, null, 2));\n\n// Determine error severity\nlet severity = 'medium';\nif (error.http_code >= 500 || error.error_type.includes('Database')) {\n  severity = 'high';\n} else if (error.http_code >= 400 && error.http_code < 500) {\n  severity = 'low';\n}\n\n// Create alert message\nconst alertMessage = {\n  subject: `Workflow Error: ${error.workflow_name}`,\n  body: `Error Details:\\nType: ${error.error_type}\\nMessage: ${error.error_message}\\nNode: ${error.node_name}\\nTime: ${error.timestamp}\\nExecution: ${error.execution_id}`,\n  severity: severity,\n  requires_attention: severity === 'high'\n};\n\nreturn [{json: {\n  error_details: error,\n  alert_message: alertMessage,\n  recovery_action: 'logged_and_alerted'\n}}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "notes": "Connect this to error outputs of other nodes"
      }
    },
    "email_notification": {
      "name": "Email Notification Template",
      "description": "Standard email notification with template formatting",
      "node": {
        "parameters": {
          "fromEmail": "noreply@company.com",
          "toEmail": "{{ $json.recipient_email || 'admin@company.com' }}",
          "subject": "{{ $json.email_subject || 'Workflow Notification' }}",
          "message": "Dear {{ $json.recipient_name || 'User' }},\\n\\n{{ $json.email_body || 'This is a notification from your n8n workflow.' }}\\n\\nDetails:\\n{{ Object.entries($json.details || {}).map(([key, value]) => `${key}: ${value}`).join('\\n') }}\\n\\nBest regards,\\nAutomation System\\n\\nTimestamp: {{ new Date().toISOString() }}",
          "options": {
            "allowUnauthorizedCerts": false,
            "replyTo": "noreply@company.com"
          }
        },
        "type": "n8n-nodes-base.emailSend",
        "typeVersion": 2,
        "credentials": {
          "smtp": {
            "id": "smtp-main",
            "name": "Main SMTP"
          }
        },
        "notes": "Configure SMTP credentials and customize email template"
      }
    },
    "conditional_switch": {
      "name": "Conditional Routing Switch",
      "description": "Switch node template for conditional routing based on data values",
      "node": {
        "parameters": {
          "mode": "expression",
          "output": "specified",
          "rules": {
            "rules": [
              {
                "id": "condition_1",
                "outputIndex": 0,
                "value": "={{ $json.status === 'active' }}"
              },
              {
                "id": "condition_2", 
                "outputIndex": 1,
                "value": "={{ $json.status === 'inactive' }}"
              },
              {
                "id": "condition_3",
                "outputIndex": 2,
                "value": "={{ $json.priority === 'high' }}"
              }
            ]
          },
          "fallbackOutput": 3
        },
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3,
        "notes": "Customize conditions based on your data structure and routing needs"
      }
    },
    "data_transformation": {
      "name": "Data Transformation Set Node",
      "description": "Template for common data transformation operations",
      "node": {
        "parameters": {
          "mode": "manual",
          "duplicateItem": false,
          "assignments": {
            "assignments": [
              {
                "id": "timestamp",
                "name": "processed_at",
                "type": "string",
                "value": "={{ new Date().toISOString() }}"
              },
              {
                "id": "full_name",
                "name": "full_name", 
                "type": "string",
                "value": "={{ ($json.first_name || '') + ' ' + ($json.last_name || '') }}"
              },
              {
                "id": "email_domain",
                "name": "email_domain",
                "type": "string", 
                "value": "={{ $json.email ? $json.email.split('@')[1] : '' }}"
              },
              {
                "id": "status_normalized",
                "name": "status",
                "type": "string",
                "value": "={{ $json.status ? $json.status.toLowerCase().trim() : 'unknown' }}"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3,
        "notes": "Add or modify field assignments based on transformation requirements"
      }
    },
    "batch_processor": {
      "name": "Batch Processing Template",
      "description": "Split in batches node with optimal configuration",
      "node": {
        "parameters": {
          "batchSize": 50,
          "options": {
            "reset": false
          }
        },
        "type": "n8n-nodes-base.splitInBatches",
        "typeVersion": 3,
        "notes": "Adjust batch size based on downstream processing capacity and memory limits"
      }
    },
    "merge_results": {
      "name": "Merge Results Template",
      "description": "Merge node to combine outputs from parallel processing",
      "node": {
        "parameters": {
          "mode": "combine",
          "combineBy": "combineAll",
          "options": {}
        },
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2,
        "notes": "Use after parallel processing to combine all results into single output"
      }
    }
  },
  "workflow_patterns": {
    "basic_webhook_to_email": {
      "description": "Simple webhook trigger to email notification pattern",
      "nodes": ["webhook_trigger", "data_transformation", "email_notification", "error_handler"],
      "connections": {
        "webhook_trigger": ["data_transformation"],
        "data_transformation": ["email_notification"],
        "email_notification": {
          "main": [],
          "error": ["error_handler"]
        }
      }
    },
    "api_to_database": {
      "description": "API data fetching to database storage pattern",
      "nodes": ["http_request_with_retry", "data_validation", "database_upsert", "error_handler"],
      "connections": {
        "http_request_with_retry": ["data_validation"],
        "data_validation": ["database_upsert"],
        "database_upsert": {
          "main": [],
          "error": ["error_handler"]
        }
      }
    },
    "conditional_processing": {
      "description": "Conditional routing with different processing paths",
      "nodes": ["webhook_trigger", "conditional_switch", "data_transformation", "merge_results"],
      "connections": {
        "webhook_trigger": ["conditional_switch"],
        "conditional_switch": {
          "output_0": ["data_transformation"],
          "output_1": ["data_transformation"],
          "fallback": ["error_handler"]
        },
        "data_transformation": ["merge_results"]
      }
    },
    "batch_processing": {
      "description": "Large dataset processing with batching",
      "nodes": ["webhook_trigger", "data_validation", "batch_processor", "data_transformation", "database_upsert"],
      "connections": {
        "webhook_trigger": ["data_validation"],
        "data_validation": ["batch_processor"],
        "batch_processor": ["data_transformation"],
        "data_transformation": ["database_upsert"]
      }
    }
  },
  "usage_guidelines": {
    "node_customization": {
      "ids": "Generate unique IDs for each node instance",
      "names": "Use descriptive names that indicate node purpose",
      "positions": "Set appropriate canvas positions for workflow layout",
      "credentials": "Configure proper credential references",
      "parameters": "Customize parameters for specific use case"
    },
    "error_handling": {
      "always_include": "Include error handling for external integrations",
      "logging": "Add appropriate logging for debugging",
      "notifications": "Set up alerts for critical failures",
      "recovery": "Implement retry and fallback mechanisms"
    },
    "performance": {
      "batch_size": "Optimize batch sizes based on data volume",
      "timeouts": "Set realistic timeout values",
      "memory": "Monitor memory usage for large datasets",
      "connections": "Limit concurrent connections to external services"
    },
    "security": {
      "credentials": "Never hardcode sensitive information",
      "validation": "Validate all external input",
      "sanitization": "Sanitize data before processing",
      "encryption": "Use encrypted connections for sensitive data"
    }
  }
}