{
  "database_nodes": {
    "database_upsert": {
      "name": "Database Upsert Operation",
      "description": "PostgreSQL node configured for INSERT with ON CONFLICT (upsert) operation",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "INSERT INTO table_name (id, field1, field2, updated_at) VALUES ($1, $2, $3, CURRENT_TIMESTAMP) ON CONFLICT (id) DO UPDATE SET field1 = EXCLUDED.field1, field2 = EXCLUDED.field2, updated_at = CURRENT_TIMESTAMP",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.id }}",
              "={{ $json.field1 }}",
              "={{ $json.field2 }}"
            ]
          }
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Replace table_name and fields with actual database schema"
      }
    },
    "database_select": {
      "name": "Database Select Query",
      "description": "PostgreSQL SELECT query with pagination and filtering",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT * FROM table_name WHERE field1 = $1 AND created_at >= $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.filter_value }}",
              "={{ $json.start_date || '1970-01-01' }}",
              "={{ $json.limit || 50 }}",
              "={{ $json.offset || 0 }}"
            ]
          }
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Customize WHERE clause, ORDER BY, and pagination parameters"
      }
    },
    "database_insert": {
      "name": "Database Insert Operation",
      "description": "PostgreSQL INSERT operation with returning clause",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "INSERT INTO table_name (field1, field2, field3, created_at) VALUES ($1, $2, $3, CURRENT_TIMESTAMP) RETURNING id, created_at",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.field1 }}",
              "={{ $json.field2 }}",
              "={{ $json.field3 }}"
            ]
          }
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Returns inserted record ID and timestamp for confirmation"
      }
    },
    "database_update": {
      "name": "Database Update Operation",
      "description": "PostgreSQL UPDATE operation with conditional updates",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "UPDATE table_name SET field1 = $1, field2 = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3 AND version = $4 RETURNING id, version + 1 as new_version",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.field1 }}",
              "={{ $json.field2 }}",
              "={{ $json.id }}",
              "={{ $json.version || 1 }}"
            ]
          }
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Includes optimistic locking with version field"
      }
    },
    "database_delete": {
      "name": "Database Delete Operation",
      "description": "PostgreSQL DELETE operation with soft delete option",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "UPDATE table_name SET deleted_at = CURRENT_TIMESTAMP, deleted_by = $1 WHERE id = $2 AND deleted_at IS NULL RETURNING id",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.deleted_by || 'system' }}",
              "={{ $json.id }}"
            ]
          }
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Soft delete - use hard delete query if permanent deletion is required"
      }
    },
    "database_transaction": {
      "name": "Database Transaction Block",
      "description": "PostgreSQL transaction with rollback support",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "BEGIN;\nINSERT INTO table1 (field1) VALUES ($1);\nINSERT INTO table2 (field2) VALUES ($2);\nCOMMIT;",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.value1 }}",
              "={{ $json.value2 }}"
            ]
          }
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Wrap multiple operations in transaction for data consistency"
      }
    },
    "mysql_upsert": {
      "name": "MySQL Upsert Operation",
      "description": "MySQL INSERT with ON DUPLICATE KEY UPDATE",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "INSERT INTO table_name (id, field1, field2, updated_at) VALUES (?, ?, ?, NOW()) ON DUPLICATE KEY UPDATE field1 = VALUES(field1), field2 = VALUES(field2), updated_at = NOW()",
          "additionalFields": {
            "queryReplacement": [
              "={{ $json.id }}",
              "={{ $json.field1 }}",
              "={{ $json.field2 }}"
            ]
          }
        },
        "type": "n8n-nodes-base.mysql",
        "typeVersion": 2,
        "credentials": {
          "mysql": {
            "id": "mysql-main",
            "name": "Main MySQL Database"
          }
        },
        "notes": "MySQL-specific upsert syntax using ON DUPLICATE KEY UPDATE"
      }
    },
    "database_connection_pool": {
      "name": "Database Connection Pool Check",
      "description": "Health check query to validate database connection",
      "category": "database",
      "node": {
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT 1 as health_check, NOW() as timestamp, pg_backend_pid() as connection_id",
          "additionalFields": {}
        },
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2,
        "credentials": {
          "postgres": {
            "id": "postgres-main",
            "name": "Main Database"
          }
        },
        "notes": "Use for database health monitoring and connection validation"
      }
    }
  },
  "usage_guidelines": {
    "query_optimization": {
      "indexing": "Ensure proper indexes exist for WHERE clause columns",
      "parameterization": "Always use parameterized queries to prevent SQL injection",
      "pagination": "Implement LIMIT/OFFSET for large result sets",
      "batching": "Use batch operations for multiple records"
    },
    "error_handling": {
      "connection_errors": "Handle database connection timeouts and failures",
      "constraint_violations": "Catch unique constraint and foreign key violations",
      "deadlocks": "Implement retry logic for deadlock scenarios",
      "transaction_rollback": "Always include error handling for transaction blocks"
    },
    "performance": {
      "connection_pooling": "Use connection pooling for high-throughput workflows",
      "query_timeout": "Set appropriate timeout values for long-running queries",
      "bulk_operations": "Prefer bulk operations over individual record processing",
      "read_replicas": "Use read replicas for reporting and analytics queries"
    },
    "security": {
      "credentials": "Use encrypted credential storage for database connections",
      "least_privilege": "Grant minimum required permissions to database users",
      "sql_injection": "Never concatenate user input directly into SQL queries",
      "data_encryption": "Use encrypted connections (SSL/TLS) for sensitive data"
    },
    "maintenance": {
      "monitoring": "Include database performance monitoring",
      "backup_validation": "Regularly test backup and restore procedures",
      "schema_migrations": "Version control database schema changes",
      "cleanup": "Implement data retention and cleanup policies"
    }
  }
}